{"mode":"Text","textContent":"# ------------------------------------------\n# \n# \tProject:      Dynamic Wall Maze Challenge\n#\tAuthor:       Lukas Krampitz    \n#\tCreated:      18 May 2021\n#\tDescription:  Have the robot drive around a maze to find it's exit\n# \n# ------------------------------------------\n\n# Library imports\nfrom vexcode import *\n\n#Util function used to setup movement speeds and clear chat\ndef init():\n    #set the speed to be faster\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    brain.clear()\n\n#Move the VEX robot by a grid unit\ndef driveGrid(numMove):\n    drivetrain.drive_for(FORWARD, 250 * numMove, MM)\n\n#Moves the robot in a sequence of linear paths.\n#Accepts the number of moves\n#The axis patternt the robot will take\n#And the distances the robot will drive \ndef driveSequ(sqeuenceSize, ordList, movList):\n    #go through the secuence given\n    for i in range(sqeuenceSize):\n        #set the rotation based on X or Y axis movement\n        if ordList[i] == X:\n            drivetrain.turn_to_rotation(90, DEGREES)\n        else:\n            drivetrain.turn_to_rotation(0, DEGREES)       \n        #move the robot by the desired amounts\n        drivetrain.drive_for(FORWARD, movList[i], MM)\n\n#move the robot to a specific set of co-ordinates\ndef goTo(xPos, yPos):\n    curX = location.position(X, MM)\n    curY = location.position(Y, MM)\n\n    movX = xPos - curX\n    movY = yPos - curY\n\n    #check for 1D movemnt\n    if (movX == 0):\n        driveSequ(1, [Y], [movY])\n    elif (movY == 0):\n        driveSequ(1, [X], [movX])\n    else:\n        driveSequ(2, [X, Y], [movX, movY])\n\n#get the robot's current position in the form of an X&Y pair in a List\ndef getPos():\n\n    curCoords = [location.position(X, MM), location.position(Y, MM)]\n\n    return curCoords\n\n#the logic for one single maze square movment\n#a maze square is the single square unit that the maze is comprised of\n#a maze square appears to be about 250 mm\ndef mazeSquare():\n\n    #save the direction the bot is facing\n    curAngle = drivetrain.heading(DEGREES)\n\n    #check the front for a wall\n    frontWall = front_eye.detect(RED)\n    \n    #check the right wall\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    sideWall = front_eye.detect(RED)\n\n    #only drive forward if there is a wall to the side and none to the front\n    if (sideWall and not frontWall):\n        #return the bot to the \"forward heading\"\n        drivetrain.turn_to_heading(curAngle, DEGREES)\n        driveGrid(1)\n    elif (not sideWall): #go to the right if the right wall ends with a turn\\\n        #the bot just checked the right wall so there is no need to rotate\n        #\"straight ahead\" is already right from the curAngle forward position\n        driveGrid(1)\n    elif (sideWall and frontWall): #if a left turn is needed\n\n        #first check if this is a dead end and the bot needs to turn around\n        drivetrain.turn_for(LEFT, 180, DEGREES)\n        leftWall = front_eye.detect(RED)\n\n        if (leftWall):\n            #if it is a dead end and there IS a wall to the left then the robot needs to make an extra 90 degree turn to leave\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        driveGrid(1)\n\ndef level3():\n\n    #draw a trail to see where the robot has been\n    pen.move(DOWN)\n\n    #keep checking for the ending red checkered floor\n    while not down_eye.detect(RED):\n        #as long as the robot is not on the ending keep repeating the modual maze check\n        mazeSquare()\n        wait(10, MSEC)\n\n#this fucntion is used to detect and remove back tracking\n#Used in removing the exploration of dead ends and anything that does not lead directly to the exit of a maze\ndef removeBackTrack(aList):   #'aList' should be a 2D array. len(aList) can be any length but len(aList[x]) can only have a length of 2\n\n    removeItem = True #Does the fuction still need to remove items?\n\n    while removeItem:\n\n        removeStart = -1 #index the removal starts at\n        removeEnd = -1 #index the removal ends at\n        removeItem = False #nothing has been found to remove yet so (re-)set to false\n\n        #go through the List\n        for i in range(len(aList)): #pick an index\n            for j in range(len(aList)): #compare it to all other indexes\n\n                #ignore the exact same one\n                if (not i == j):\n                    #get the x any y positions for that position\n                    xPosI = aList[i][0]\n                    yPosI = aList[i][1]\n\n                    xPosJ = aList[j][0]\n                    yPosJ = aList[j][1]\n\n                    #check if they are very nearly the same spot\n                    if (abs(xPosI - xPosJ) < 100 and abs(yPosI - yPosJ) < 100):\n                        \n                        #make note of the part that needs to be removed\n                        removeItem = True\n                        removeStart = i\n                        removeEnd = j\n\n        #check if items need to be removed\n        if (removeItem):\n            brain.print(\"\\nRem from: \" + str(removeStart) + \" - \" + str(removeEnd))\n            #remove all the elements that are inbetween the duplicates\n            for num in range(abs(removeEnd-removeStart)):\n                aList.pop(removeEnd)\n        \n        wait(1, MSEC)\n\n    return aList\n\ndef level4():\n\n    #draw trail\n    pen.move(DOWN)\n\n    #get the co-ordinates\n    curCoords = getPos()\n    #save them to a list of places the robot has been\n    posList = [curCoords]\n\n    #now complete the maze using the right wall following method\n    while not down_eye.detect(RED):\n        #preform the single unit action\n        mazeSquare()\n        #log the new position of the robot\n        curCoords = getPos()\n        posList.append(curCoords)\n        wait(10, MSEC)\n\n    #take the log of position the robot had and remove sections that contain detours taken by the bot\n    brain.print(\"\\nPosList: \\n\" + str(posList))\n    posList = removeBackTrack(posList)\n    brain.print(\"\\nPosList: \\n\" + str(posList))\n\n    #change the colour of the trail the bot leaves behind to make the optimal route more obvious\n    pen.set_pen_color(GREEN)\n\n    #now go back to beginning using the shortest path\n    for i in range( (len(posList) - 2), -1, -1 ):\n        goTo(posList[i][0] + 5, posList[i][1] + 5)    \n\n# Add project code in \"main\"\ndef main():\n    init()\n\n    level4()\n\n# VR threads â€” Do not delete\nvr_thread(main())\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":"","playground":"DynamicWallMaze"}